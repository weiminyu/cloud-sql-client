buildscript {
  // Lock buildscript dependencies.
  configurations.classpath {
    resolutionStrategy.activateDependencyLocking()
  }
}

plugins {
  id 'com.diffplug.gradle.spotless' version '3.18.0' apply false
  // gradlew <GradleTask> taskTree
  id "com.dorongold.task-tree" version "1.4"

  id 'jacoco'
}

dependencyLocking {
    lockAllConfigurations()
  }


subprojects { 

  repositories {
    mavenCentral()
  }

  buildscript {
    // Lock buildscript dependencies.
    configurations.classpath {
      resolutionStrategy.activateDependencyLocking()
    }
  }

  // Lock application dependencies.
  dependencyLocking {
    lockAllConfigurations()
  }

  apply plugin: 'java'
  apply plugin: 'java-library'
  apply plugin: 'com.diffplug.gradle.spotless'
  apply plugin: 'jacoco'

  spotless {
    java {
      googleJavaFormat()
    }
    format 'misc', {
      target '**/*.gradle', '**/*.md', '**/.gitignore', '**/*.sql'

      targetExclude 'src/test/resources/**/*.sql'

      trimTrailingWhitespace()
      indentWithSpaces(2)
      endWithNewline()
    }
  }

  ext.getPropertyOrDefault = { name, defaultValue ->
    if (project.hasProperty(name)) {
      return project.findProperty(name)
    }
    return defaultValue
  }

  dependencies {
    compile 'com.google.guava:guava:26.0-jre'

    testCompile 'com.google.truth.extensions:truth-java8-extension:0.45'
    testCompile 'com.google.truth:truth:0.45'
    testCompile 'junit:junit:4.13-beta-2'
  }

  test {
    testLogging.showStandardStreams = true
    finalizedBy jacocoTestReport
  }

  task checkConflictingChanges {
    doLast {
      def appChanges =
          rootProject.ext.changedFileCount('subprojects/demo_app', false)
      def schemaChanges =
          rootProject.ext.changedFileCount('subprojects/demo_schema', false)

      if (appChanges > 0 && schemaChanges > 0) {
        throw new IllegalStateException(
            'Simultaneous changes to both demo_schema and demo_app '
                + 'may not be submitted.')
      }
    }
  }
  build.finalizedBy checkConflictingChanges
}

// Executes an arbitrary shell command in bash and returns all output
// to stdout as a string. This method allows pipes in shell command.
rootProject.ext.execWithBash = { shellCommand, bashWorkingDir ->
  return new ByteArrayOutputStream().withStream { os ->
    exec {
      workingDir bashWorkingDir
      commandLine 'bash', '-c', "${shellCommand}"
      standardOutput os
    }
    return os
  }.toString()
}

// Counts the changed files under the given folder against origin/master.
rootProject.ext.changedFileCount = { folderName, stagedOnly ->
  def shellCommand =
          String.format('git diff --name-only %s origin/master %s | wc -l',
              stagedOnly ? '--staged' : '',
              folderName)
  return Integer.valueOf(
          rootProject.ext.execWithBash(shellCommand, rootDir).trim())
}
